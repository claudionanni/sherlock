#!/usr/bin/python3

#SHERLOCK © 2020 - Claudio Nanni

# Module Imports
import mariadb
import sys
import os
import time
import json
import requests
from datetime import datetime
from string import digits
import argparse


def download_commands_from_url():
    try:
       url = 'https://raw.githubusercontent.com/claudionanni/sherlock/master/sherlock_cmd.json'
       r = requests.get(url, allow_redirects=True)
       open('./sherlock_cmd.json', 'wb').write(r.content)
    except:
       print("Commands file could not be downloaded from the internet, will try to use the local copy.")

def load_commands_from_file():
    try:
        with open('./sherlock_cmd.json') as f:
            Commands = json.load(f)
            return Commands
    except:
        print("Could not load local commands file, we can't proceed.")
        exit()


## Add management for 'la' a=all linux commands
def exec_commands(cmdNum,lstCmds):
   print("\n")
   if(cmdNum=='la'):
      lDict = {k: v for k, v in lstCmds.items() if k.startswith('l')}
      for k in lDict:
         (TYPE,USER_TYPE,COMMAND,DESCRIPTION)=lstCmds[k]
         output_file=str(k)+".shock"
         full_command=COMMAND + " > " + output_file
         print("_"*120)
         print("\n",str(k),":: ",full_command,"\t\t\t (",DESCRIPTION,")")
         if(USER_TYPE!='h'):
            os.system(full_command)
            if(args.verbose):
                print("_"*120)
                os.system('cat ' + output_file)
                print("¨"*120)
         else:
             print("\nNOTE: Command needs manual execution!")
   else:    
      (TYPE,USER_TYPE,COMMAND,DESCRIPTION)=lstCmds[cmdNum]
      output_file=str(cmdNum)+".shock"
      full_command=COMMAND + " > " + output_file
      print("_"*120)
      print("\n",cmdNum,":: ",full_command,"\t\t\t (",DESCRIPTION,")")
      if(USER_TYPE!='h'):
         os.system(full_command)
         if(args.verbose):
             print("_"*120)
             os.system('cat ' + output_file)
             print("¨"*120)
      else:
          print("\nNOTE: ",str(cmdNum), ":: command needs manual execution!")


## Add management for 'ma' a=all mdb commands
def exec_mariadb(cmdNum,lstCmds,user='-',pwd='-',host='-',port='-'):
   if(cmdNum=='ma'):
       mDict = {k: v for k, v in lstCmds.items() if k.startswith('m')}
       for k in mDict:    
            (TYPE,USER_TYPE,COMMAND,DESCRIPTION)=lstCmds[k]
            output_file=str(k)+".shock"
            full_command="mysql -u"+user+" -p"+pwd+" -h"+host+" -P"+port+" -e \""+COMMAND+"\""
            print("_"*120)
            print(full_command+" > "+output_file)
            if(USER_TYPE!='h'):
                os.system(full_command + " > " + output_file)
                if(args.verbose):
                    print("_"*120)
                    os.system('cat ' + output_file)
                    print("¨"*120)
            else:
                print("\nNOTE:",str(k),":: command needs manual execution")
   else:
       (TYPE,USER_TYPE,COMMAND,DESCRIPTION)=lstCmds[cmdNum]
       output_file=str(cmdNum)+".shock"
       full_command="mysql -u"+user+" -p"+pwd+" -h"+host+" -P"+port+" -e \""+COMMAND+"\""
       print("_"*120)
       print(full_command+" > "+output_file)
       if(USER_TYPE!='h'):
            os.system(full_command + " > " + output_file)
            if(args.verbose):
                print("_"*120)
                os.system('cat ' + output_file)
                print("¨"*120)
       else:
            print("Command needs manual execution")


def list_commands():
   print("\nList of available commands:")
   ### HERE There is some censorship on the prefix of possible commands, decide what to do
   mDict = {k: v for k, v in listCommands.items() if k.startswith('m') or k.startswith('l')}
   for k in mDict:
       (TYPE,USER_TYPE,COMMAND,DESCRIPTION)=listCommands[k]
       print(k,"\t: (",TYPE,"/",USER_TYPE,") [",COMMAND[:25].ljust(25),"] \t\t--> ",DESCRIPTION)
   print("la = all linux commands")
   print("ma = all mariadb commands")
   print("/ h = needs manual edit for execution")
   print("-"*120)


###
###  MAIN SECTION - Executed at startup
###

print("\n\nSHERLOCK ©2020 By Claudio The Nanni")

parser = argparse.ArgumentParser(prog='shock',description='Collects info from the OS and a MariaDB instance for incident investigation.')
parser.add_argument("-H","--host", metavar='<hostname or ip>',default='127.0.0.1',help='Hostname or ip of the MariaDB instance')
parser.add_argument("-P","--port", metavar='<port>',default='3306',help='Port the MariaDB instance')
parser.add_argument("-u","--user", metavar='<user>',default='root',help='User of the MariaDB instance')
parser.add_argument("-p","--password", metavar='<password>',default='',help='Password of the MariaDB instance')
parser.add_argument("-c","--commands", metavar='<command>,',nargs='*',help='It takes a comma separated list of commands')
parser.add_argument("-v","--verbose",action="store_true",help='Also prints the commands output on screen')
args = parser.parse_args()


timestampedFolder=''
def createTimestampedFolder():
    timestampedFolder=datetime.now().strftime("%Y%m%d-%H%M%S")
    path="shock-" + timestampedFolder
    print("All collected data will be placed in the folder: ",path,"\n")
    try:
        os.mkdir(path)
    except OSError:
        print ("Creation of the directory %s failed" % path)
    else:
        #print ("Successfully created the directory %s " % path)
        os.chdir(path)



download_commands_from_url()
listCommands={}
listCommands=load_commands_from_file()

if(args.commands==None):
    list_commands()
else:
    createTimestampedFolder()
    cmdList=args.commands[0].split(',')
    for i in cmdList:
        iSin=i[:1]
        if(iSin=='l'):
           exec_commands(i,listCommands)
        if(iSin=='m'):
           exec_mariadb(i,listCommands,args.user,args.password,args.host,args.port)

print("\nExiting...\n")
